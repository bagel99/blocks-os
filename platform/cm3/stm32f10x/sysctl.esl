/*
 * STM32F10x chip specific stuff not associated with a single device.
 *
 * Copyright (c) 2011, Brian G. Lucas.  See LICENSE file.
 * $Id: sysctl.esl 283 2012-02-02 22:32:42Z bgl $
 */

package sysctl
{
    type ClockSource: (HSI, HSE, PLL, INVALID);
    type APBPreScale: (DIV1, DIV2=0b100, DIV4, DIV8, DIV16);
    type PLLMulFactor: (MUL8=6, MUL9,
			MUL10, MUL11, MUL12, MUL13, MUL14, _, MUL16, MUL20);
    type MCOSel: (_,    _,    _,   _,       SYSCLK, HSI, HSE, PLL_2,
    	          PLL2, PLL3_2, XT1, PLL3, _,      _,   _,   _ );

    type Bus: (APB2, APB1, AHB, NOBUS);
    // The following is used to index into bit arrays for reset and clock enable
    type Device:
    (   // 32 APB2 DEVICES
	AFIO,   _,      IOPA,   IOPB,   IOPC,   IOPD,   IOPE,   IOPF,
	IOPG,   ADC1,   ADC2,   TIM1,   SPI1,   TIM8,   USART1, ADC3,
	_,      _,      _,      TIM9,   TIM10,  TIM11,  _,      _,
	_,      _,      _,      _,      _,      _,      _,      _,
	// 32 APB1 DEVICES
	TIM2,   TIM3,   TIM4,   TIM5,   TIM6,   TIM7,   TIM12,  TIM13,
	TIM14,  _,      _,      WWDG,   _,      _,      SPI2,   SPI3,
	_,      USART2, USART3, UART4,  UART5,  I2C1,   I2C2,   USB,
	_,      CAN,    BKP,    PWR,    DAC,    _,      _,      _,
	// 32 AHB DEVICES
	DMA1,   DMA2,   SRAM,   _,      FLITF,  _,      CRC,    _,
	_,      _,      _,      _,      OTGFS,  _,      ETHMAC, ETHTX,
	ETHRX,  _,      _,      _,      _,      _,      _,      _,
	_,      _,      _,      _,      _,      _,      _,      NODEV	
    );
	
    type RCCRegs:
    {   cr:	// 0x00  reset=0x00_00_XX_83
	{   hsi:
	    {   on:  boolean;
		rdy: boolean: ro;
		_:      0..1;
		trim:0..31;
	    }: packed, lsb, in, out;
    	    hsical: 0..255: ro;
    	    hse:
    	    {   on:  boolean;
    		rdy: boolean: ro;
    		byp: boolean;
    		csson:  boolean;
    		_:      0..0b1111;
	    }: packed, lsb, in, out;
	    pll:
    	    {   on:  boolean;
    		rdy: boolean: ro;
    		on2: boolean;
    		rdy2:boolean: ro;
    		on3: boolean;
    		rdy3:boolean: ro;
    		_:      0..0b11;
    	    }: packed, lsb, in, out;
    	};
    	cfg:	// 0x04  reset=0x00_00_00_00
    	{   sel:
	    {   sw:    ClockSource;
		sws:   ClockSource: ro;
		hpre:  (DIV1, DIV2=0b1000, DIV4, DIV8, DIV16,
    		        DIV64, DIV128, DIV256, DIV512);
    	    }: packed, lsb, in, out;
    	    pre:
    	    {   p1:  APBPreScale;
		p2:  APBPreScale;
		adc: (DIV2, DIV4, DIV6, DIV8);
    	    }: packed, lsb, in, out;
    	    pll:
    	    {   src:      (HSI, HSE_DIV1);
    	        xtpre:    boolean;
    	        mul:      (NONE, _, BY4, BY5, BY6, BY7,   BY8, BY9,
    	                   _,    _, _,   _,   _,   BY6_5, _,   _);
    	        otgfspre: (DIV3, DIV2);
    	        _:        0..1;
    	    }: packed, lsb, in, out;
     	    mco:
    	    {   sel: MCOSel;
    	        _:   0..0b1111;
    	    }: packed, lsb, in, out;
    	};
    	cir:	// 0x08
    	{   rdy:
    	    {   lsi:  boolean: ro;
    		lse:  boolean: ro;
    		hsi:  boolean: ro;
    		hse:  boolean: ro;
    		pll:  boolean: ro;
    		pll2: boolean: ro;
    		pll3: boolean: ro;
    		css:  boolean: ro;
    	    }: packed, lsb, in;
    	    enb:
    	    {   lsi:  boolean;
    		lse:  boolean;
    		hsi:  boolean;
    		hse:  boolean;
    		pll:  boolean;
    		pll2: boolean;
    		pll3: boolean;
    		css:  boolean;
    	    }: packed, lsb, in, out;
    	    clr:
    	    {   lsi:  boolean: wo;
    		lse:  boolean: wo;
    		hsi:  boolean: wo;
    		hse:  boolean: wo;
    		pll:  boolean: wo;
    		pll2: boolean: wo;
    		pll3: boolean: wo;
    		css:  boolean: wo;
    	    }: packed, lsb, out;
    	    _: 0..0xFF;
    	};
    	apb2rst: [32] 0..1: packed, lsb, in, out;	// 0x0C
    	apb1rst: [32] 0..1: packed, lsb, in, out;	// 0x10
    	ahbclk:  [32] 0..1: packed, lsb, in, out;	// 0x14
    	apb2clk: [32] 0..1: packed, lsb, in, out;	// 0x18
    	apb1clk: [32] 0..1: packed, lsb, in, out;	// 0x1C
    	bdcr:    _uint32;				// 0x20
    	csr:     _uint32;				// 0x24
    	ahbrst:  [32] 0..1: packed, lsb, in, out;	// 0x28
    	cfg2:
    	{   prediv1: 0..15;	// div by n+1
    	    prediv2: 0..15;	// div by n+1
    	    pll2mul: PLLMulFactor;
    	    pll3mul: PLLMulFactor;
    	    div1src: (HSE, PLL2);
    	    i2s2src: (SYSCLK, PLL3);
    	    i2s3src: (SYSCLK, PLL3);
    	    _:       0..0x1FFF;
    	}: packed, lsb, in, out;
     };

    type SysCtl: @RCCRegs;
    const SysCtlAddr: SysCtl = 0x4002_1000;

    type FlashRegs:
    {   acr:    // 0x00  reset=0x0000_0030
	{   ws:    0..7;    // only 0,1,2 valid
	    hcae:  boolean;
	    pfbe:  boolean;
	    prbs:  boolean: ro;
	    _:     0..0x3FFFFFF;
    	}: packed, lsb, in, out;
    };
    type FlashCtl: @FlashRegs;
    const FlashCtlAddr: FlashCtl = 0x4002_2000;

    proc ClockEnable(which: Device)
    {   var sc: SysCtl;
	var i: _uint;

	sc = SysCtlAddr;
	i = _uint(which);
	if i < 32 then
	    sc.apb2clk[i] = 1;
	else if i < 64 then
	    sc.apb1clk[i-32] = 1;
        else
	    sc.ahbclk[i-64] = 1;
    }

    proc DeviceReset(which: Device)
    {   var sc: SysCtl;
	var i: _uint;

	sc = SysCtlAddr;
	i = _uint(which);
	if i < 32 then
	{   sc.apb2rst[i] = 1;
	    sc.apb2rst[i] = 0;
	}
	else if i < 64 then
	{   sc.apb1rst[i-32] = 1;
	    sc.apb1rst[i-32] = 0;
	}
        else
	{   sc.ahbrst[i-64] = 1;
	    sc.ahbrst[i-64] = 0;
	}
    }

    proc MCOInit(sel: MCOSel)
    {   var sc: SysCtl;

	sc = SysCtlAddr;
	sc.cfg.mco.sel = sel;
    }

    proc PLL3Init(mul: PLLMulFactor)
    {   var sc: SysCtl;

	sc = SysCtlAddr;
	sc.cfg2.pll3mul = mul;
	sc.cr.pll.on3 = true;
	while !sc.cr.pll.rdy3 do {}   // FIXME: infinite?
    }

    proc Init()
    {   var sc: SysCtl;
	var fc: FlashCtl;
    	var n: _uint;

	sc = SysCtlAddr;
	sc.cr.hsi.on = true;	// make sure HSI in on
	// Redundant? These should already be zero after reset
	sc.cfg.sel = { .sw=HSI, .hpre=DIV1 };
	sc.cfg.pre = { .p1=DIV1, .p2=DIV1, .adc=DIV2 };
	// Redundant? These should already be zero after reset
	sc.cr.hse.on = false;
	sc.cr.hse.csson = false;
	sc.cr.hse.byp = false;
	// Redundant? These should already be zero after reset
	sc.cfg.pll = { .src=HSI, .xtpre=false, .mul=NONE, .otgfspre=false };
	// Redundant? These should be zero after reset
	sc.cr.pll.on2 = false;
	sc.cr.pll.on3 = false;
	// disable all interrupts and clear all flags
        sc.cir.enb = { .lsi=false /* all false */ };
        sc.cir.clr = { .lsi=true, .lse=true, .hsi=true, .hse=true,
        	       .pll=true, .pll2=true, .pll3=true, .css=true };
	// WARNING: Following code assumes 72MHz cpu clock
        sc.cr.hse.on = true;	// enable HSE
        n = 0x500;
        while !sc.cr.hse.rdy && n > 0 do n -= 1;	// wait loop
        if !sc.cr.hse.rdy then return;	// FIXME: fatal error
        // Enable Flash prefetch and use 2 wait states
        fc = FlashCtlAddr;
        fc.acr.pfbe = true;
        fc.acr.ws = 2;
        // Now set up PLL and Clocks
        sc.cfg.sel.hpre = DIV1;		    // HCLK = SYSCLK
        sc.cfg.pre = { .p1=DIV2, .p2=DIV1 };// PCLK1 = HCLK/2, PCLK2 = HCLK
	// PLL2 configuration:
	//	PLL2CLK = (HSE / 5) * 8 = 40 MHz
	//	PREDIV1CLK = PLL2 / 5 = 8 MHz
	sc.cfg2 = { .prediv1=5-1, .prediv2=5-1, .pll2mul=MUL8, .div1src=PLL2 };      
        sc.cr.pll.on2 = true;
        while !sc.cr.pll.rdy2 do {}	// FIXME: infinite? what timeout?
        // PLL configuration:
        //	PLLCLK = PREDIV1CLK * 9 = 72 MHz
 	sc.cfg.pll = { .src=HSE_DIV1, .xtpre=false, .mul=BY9 };
	sc.cr.pll.on = true;
	while !sc.cr.pll.rdy do {}	// FIXME: infinite? what timeout?
	// Select PLL as clock source and wait until it takes
	sc.cfg.sel.sw = PLL;
	while sc.cfg.sel.sws != PLL do {}	// FIXME: infinite?
    }
}
// vim: ts=8 sw=4 noet nowrap

