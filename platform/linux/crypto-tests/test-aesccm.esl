// TEST: test aesccm
// http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/AES_CCM.pdf

import debug;
alias debug as err;

proc print16x(x: @[16]_byte)
{   var i: _uint;

    for i from 0 to 15 do
    {	debug.hex8(x[i]);
    	debug.chr(' ');
    }
    debug.nl();
}

proc printnx(x: @[]_byte, n: _uint)
{   var i: _uint;

    for i from 0 to n-1 do
    {	debug.hex8(x[i]);
    	debug.chr(' ');
    }
    debug.nl();
}

import aesccm;


type Test:
{   klen:  _uint8;
    nlen:  _uint8;
    alen:  _uint8;
    tlen:  _uint8;
    mlen:  _uint16;
    key:   @[]_byte;
    nonce: @[]_byte;
    adata: @[]_byte;
    plain: @[]_byte;
    cipher:@[]_byte;
    tag:   @[]_byte;	// aka MAC
};

const tests: []Test =
{

  {	// NIST SP800-C example C.1
    .klen=16, .nlen=7, .alen=8, .tlen=4, .mlen=4,
    .key={
	0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f
    },
    .nonce={
	0x10,0x11,0x12,0x13,0x14,0x15,0x16
    },
    .adata={
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
    },
    .plain={
	0x20,0x21,0x22,0x23
    },
    .cipher={
	0x71,0x62,0x01,0x5b
    },
    .tag={
	0x4d,0xac,0x25,0x5d
    }
  },
  {	// NIST SP800-C example C.2
    .klen=16, .nlen=8, .alen=16, .tlen=6, .mlen=16,
    .key={
	0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f
    },
    .nonce={
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17
    },
    .adata={
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
    },
    .plain={
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f
    },
    .cipher={
	0xd2,0xa1,0xf0,0xe0,0x51,0xea,0x5f,0x62,0x08,0x1a,0x77,0x92,0x07,0x3d,0x59,0x3d
    },
    .tag={
	0x1f,0xc6,0x4f,0xbf,0xac,0xcd
    }
  },    
  {	// NIST SP800-C example C.3
    .klen=16, .nlen=12, .alen=20, .tlen=8, .mlen=24,
    .key={
	0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f
    },
    .nonce={
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b
    },
    .adata={
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x10,0x11,0x12,0x13
    },
    .plain={
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37
    },
    .cipher={
	0xe3,0xb2,0x01,0xa9,0xf5,0xb7,0x1a,0x7a,0x9b,0x1c,0xea,0xec,0xcd,0x97,0xe7,0x0b,
	0x61,0x76,0xaa,0xd9,0xa4,0x42,0x8a,0xa5
    },
    .tag={
	0x48,0x43,0x92,0xfb,0xc1,0xb0,0x99,0x51
    }
  },
};


var nerr: _uint = 0;

proc Check(test: boolean, msg: @[]_byte, n: _uint)
{
    if !test then
    {   err.str("Test "); err.uint(n); err.str(" failed: ");
	err.str(msg);
	err.nl();
	nerr += 1;
    }
}

var ciphertext: [32]_byte;
var resulttext: [32]_byte;
var tag: [16]_byte;

var ctx: aesccm.State;

proc main(): _int
{   var len, alen, nlen, tlen: _uint;
    var i: _uint;

    for i from 0 to tests?len-1 do
    {
	// FIXME - klen != 16
	len = tests[i].mlen;
	alen = tests[i].alen;
	nlen = tests[i].nlen;
	tlen = tests[i].tlen;

	// Encrypt
	ctx.SetKey(tests[i].key, KEY128);
	ctx.Start(alen, len, tlen, tests[i].nonce, nlen);
	ctx.Header(tests[i].adata, alen);
	ctx.Encrypt(tests[i].plain, ciphertext, len);
	Check(ciphertext[0:len] == tests[i].cipher[0:len], "encrypt", i);
	ctx.Finish(tag, tlen);
	Check(tag[0:tlen] == tests[i].tag[0:tlen], "encrypt tag", i);

	// Decrypt
	ctx.SetKey(tests[i].key, KEY128);
	ctx.Start(alen, len, tlen, tests[i].nonce, nlen);
	ctx.Header(tests[i].adata, alen);
	ctx.Decrypt(ciphertext, resulttext, len);
	Check(resulttext[0:len] == tests[i].plain[0:len], "decrypt", i);
	ctx.Finish(tag, tlen);
	Check(tag[0:tlen] == tests[i].tag[0:tlen], "encrypt tag", i);
    }
    return _int(nerr);
}

