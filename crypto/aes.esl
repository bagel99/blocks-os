/*
 * Advanced Encryption Standard (AES)
 * See NIST FIPS Pub. 197
 * Copyright Brian G. Lucas, 2011.
 * License: New BSD.
 *
 * Notes:
 * 1. The algorithm is specified the state as a column major 4x4 array.
 *    We will store in row major order.  Thus rows and columns are interchanged
 *    relative to FIPS-197.
 * 2. The algorithm sometimes uses 4 bytes at a time in big-endian
 *    representation.  This implementation stores them little-endian.
 *    FIXME: This code only works little-endian.
 */

package aes
{
    type KeySize: (UNKNOWN, KEY128, KEY192, KEY256);

    type Word: _uint32;
    const Nb = 4;		// number of bytes in a Word
    const MaxNr = 14;		// for 256-bit key, 14 rounds
    /*
     * Expanded Key:  If the key is used for multiple Encrypt/Decrypt
     * it is more efficient to just expand it once.
     * It takes a lot of space though.
     */
    type ExpandedKey: [Nb*(MaxNr+1)]Word;
    var KeyX: ExpandedKey;
    var Nk: _uint8;		// number of words in current key

    // State is sometimes accessed as bytes and sometimes as 32-bit words.
    type State: [16]_uint8;

    const Rcon: [MaxNr]_uint8 =
    { 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d };



    // S-box, see pg 16 of FIPS-197
    const sbox: [256]_uint8 = {
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
    };

    // Inverse S-box
    const invsbox: [256]_uint8 = {
    0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
    0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
    0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
    0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
    0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
    0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
    0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
    0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
    0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
    0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
    0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
    0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
    0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
    0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
    0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
    0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
    };

    // Precomputed Galois multiplication by 2 modulo 
    const G2: [256]_uint8 = {
    0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x14,0x16,0x18,0x1A,0x1C,0x1E,
    0x20,0x22,0x24,0x26,0x28,0x2A,0x2C,0x2E,0x30,0x32,0x34,0x36,0x38,0x3A,0x3C,0x3E,
    0x40,0x42,0x44,0x46,0x48,0x4A,0x4C,0x4E,0x50,0x52,0x54,0x56,0x58,0x5A,0x5C,0x5E,
    0x60,0x62,0x64,0x66,0x68,0x6A,0x6C,0x6E,0x70,0x72,0x74,0x76,0x78,0x7A,0x7C,0x7E,
    0x80,0x82,0x84,0x86,0x88,0x8A,0x8C,0x8E,0x90,0x92,0x94,0x96,0x98,0x9A,0x9C,0x9E,
    0xA0,0xA2,0xA4,0xA6,0xA8,0xAA,0xAC,0xAE,0xB0,0xB2,0xB4,0xB6,0xB8,0xBA,0xBC,0xBE,
    0xC0,0xC2,0xC4,0xC6,0xC8,0xCA,0xCC,0xCE,0xD0,0xD2,0xD4,0xD6,0xD8,0xDA,0xDC,0xDE,
    0xE0,0xE2,0xE4,0xE6,0xE8,0xEA,0xEC,0xEE,0xF0,0xF2,0xF4,0xF6,0xF8,0xFA,0xFC,0xFE,
    0x1B,0x19,0x1F,0x1D,0x13,0x11,0x17,0x15,0x0B,0x09,0x0F,0x0D,0x03,0x01,0x07,0x05,
    0x3B,0x39,0x3F,0x3D,0x33,0x31,0x37,0x35,0x2B,0x29,0x2F,0x2D,0x23,0x21,0x27,0x25,
    0x5B,0x59,0x5F,0x5D,0x53,0x51,0x57,0x55,0x4B,0x49,0x4F,0x4D,0x43,0x41,0x47,0x45,
    0x7B,0x79,0x7F,0x7D,0x73,0x71,0x77,0x75,0x6B,0x69,0x6F,0x6D,0x63,0x61,0x67,0x65,
    0x9B,0x99,0x9F,0x9D,0x93,0x91,0x97,0x95,0x8B,0x89,0x8F,0x8D,0x83,0x81,0x87,0x85,
    0xBB,0xB9,0xBF,0xBD,0xB3,0xB1,0xB7,0xB5,0xAB,0xA9,0xAF,0xAD,0xA3,0xA1,0xA7,0xA5,
    0xDB,0xD9,0xDF,0xDD,0xD3,0xD1,0xD7,0xD5,0xCB,0xC9,0xCF,0xCD,0xC3,0xC1,0xC7,0xC5,
    0xFB,0xF9,0xFF,0xFD,0xF3,0xF1,0xF7,0xF5,0xEB,0xE9,0xEF,0xED,0xE3,0xE1,0xE7,0xE5
    };

    // Precomputed Galois multiplication by 3 modulo 
    const G3: [256]_uint8 = {
    0x00,0x03,0x06,0x05,0x0C,0x0F,0x0A,0x09,0x18,0x1B,0x1E,0x1D,0x14,0x17,0x12,0x11,
    0x30,0x33,0x36,0x35,0x3C,0x3F,0x3A,0x39,0x28,0x2B,0x2E,0x2D,0x24,0x27,0x22,0x21,
    0x60,0x63,0x66,0x65,0x6C,0x6F,0x6A,0x69,0x78,0x7B,0x7E,0x7D,0x74,0x77,0x72,0x71,
    0x50,0x53,0x56,0x55,0x5C,0x5F,0x5A,0x59,0x48,0x4B,0x4E,0x4D,0x44,0x47,0x42,0x41,
    0xC0,0xC3,0xC6,0xC5,0xCC,0xCF,0xCA,0xC9,0xD8,0xDB,0xDE,0xDD,0xD4,0xD7,0xD2,0xD1,
    0xF0,0xF3,0xF6,0xF5,0xFC,0xFF,0xFA,0xF9,0xE8,0xEB,0xEE,0xED,0xE4,0xE7,0xE2,0xE1,
    0xA0,0xA3,0xA6,0xA5,0xAC,0xAF,0xAA,0xA9,0xB8,0xBB,0xBE,0xBD,0xB4,0xB7,0xB2,0xB1,
    0x90,0x93,0x96,0x95,0x9C,0x9F,0x9A,0x99,0x88,0x8B,0x8E,0x8D,0x84,0x87,0x82,0x81,
    0x9B,0x98,0x9D,0x9E,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8F,0x8C,0x89,0x8A,
    0xAB,0xA8,0xAD,0xAE,0xA7,0xA4,0xA1,0xA2,0xB3,0xB0,0xB5,0xB6,0xBF,0xBC,0xB9,0xBA,
    0xFB,0xF8,0xFD,0xFE,0xF7,0xF4,0xF1,0xF2,0xE3,0xE0,0xE5,0xE6,0xEF,0xEC,0xE9,0xEA,
    0xCB,0xC8,0xCD,0xCE,0xC7,0xC4,0xC1,0xC2,0xD3,0xD0,0xD5,0xD6,0xDF,0xDC,0xD9,0xDA,
    0x5B,0x58,0x5D,0x5E,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4F,0x4C,0x49,0x4A,
    0x6B,0x68,0x6D,0x6E,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7F,0x7C,0x79,0x7A,
    0x3B,0x38,0x3D,0x3E,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2F,0x2C,0x29,0x2A,
    0x0B,0x08,0x0D,0x0E,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1F,0x1C,0x19,0x1A
    };

    // permutation table for ShiftRows
    const SR: [4*Nb]_uint8 =
    {  0, 1, 2, 3, 5, 6, 7, 4,10,11, 8, 9,15,12,13,14 };

    proc AddRoundKey(x: @State, w: @[Nb]Word)
    {   type pwb: @[4*Nb]_uint8;
	var i, j: _uint;
	var wb: pwb;

	wb = pwb(w);
	i = 0;
	while i < 16 do
	{   x[i] = x[i] ^ wb[i];
		x[i+1] = x[i+1] ^ wb[i+1];
		x[i+2] = x[i+2] ^ wb[i+2];
		x[i+3] = x[i+3] ^ wb[i+3];
		i += 4;
	}
    }

    proc SubBytes(x: @State)
    {   var i: _uint;

	i = 0;
	while i < 4*Nb do
	{   x[i] = sbox[x[i]];
		i += 1;
	}
    }

    proc InvSubBytes(x: @State)
    {   var i: _uint;

	i = 0;
	while i < 4*Nb do
	{   x[i] = invsbox[x[i]];
		i += 1;
	}
    }

    proc ShiftRows(x: @State)
    {   var t: _uint8;
	// rotate second row by 1 left
	t = x[1]; x[1] = x[5]; x[5] = x[9]; x[9] = x[13]; x[13] = t;
	// rotate third row by 2 left
	t = x[2]; x[2] = x[10]; x[10] = t;
	t = x[6]; x[6] = x[14]; x[14] = t;
	// rotate forth row by 3 left (same as 1 right)
	t = x[3]; x[3] = x[15]; x[15] = x[11]; x[11] = x[7]; x[7] = t;
    }

    proc InvShiftRows(x: @State)
    {   var t: _uint8;

	t = x[1]; x[1] = x[13]; x[13] = x[9]; x[9] = x[5]; x[5] = t;
	t = x[2]; x[2] = x[10]; x[10] = t;
	t = x[6]; x[6] = x[14]; x[14] = t;
	t = x[3]; x[3] = x[7]; x[7] = x[11]; x[11] = x[15]; x[15] = t;
    }


    proc G(x: _uint8, y: _uint8):_uint8
    {   var z, hi: _uint8;
	var i: _uint;

	i = 0;
	z = 0;
	while i < 8 do
	{   if y & 1 != 0 then z = z ^ x;
		hi = x & 0x80;
		x = x << 1;
		if hi != 0 then x = x ^ 0x1B;
		y = y >> 1;
		i += 1;
	}
	return z;
    }
       
    proc MixColumns(x: @State)
    {   var i: _uint;
	var t: [4]_uint8;

	i = 0;
	while i < 16 do
	{   //t = x[4*i:4];	// local copy
	    t[0] = x[i]; t[1] = x[i+1]; t[2] = x[i+2]; t[3] = x[i+3];
    /*
	    x[i]   = G(2, t[0]) ^ G(3, t[1]) ^ t[2]       ^ t[3];
	    x[i+1] = t[0]       ^ G(2, t[1]) ^ G(3, t[2]) ^ t[3];
	    x[i+2] = t[0]       ^ t[1]       ^ G(2, t[2]) ^ G(3, t[3]);
	    x[i+3] = G(3, t[0]) ^ t[1]       ^ t[2]       ^ G(2, t[3]);
    */
	    x[i]   = G2[t[0]] ^ G3[t[1]] ^    t[2]  ^    t[3];
	    x[i+1] =    t[0]  ^ G2[t[1]] ^ G3[t[2]] ^    t[3];
	    x[i+2] =    t[0]  ^    t[1]  ^ G2[t[2]] ^ G3[t[3]];
	    x[i+3] = G3[t[0]] ^    t[1]  ^     t[2] ^ G2[t[3]];
	    i += 4;
	}
    }

    proc InvMixColumns(x: @State)
    {   var i: _uint;
	var t: [4]_uint8;

	i = 0;
	while i < 16 do
	{   //t = x[4*i:4];	// local copy
	    t[0] = x[i]; t[1] = x[i+1]; t[2] = x[i+2]; t[3] = x[i+3];
	    x[i]   = G(0xe, t[0]) ^ G(0xb, t[1]) ^ G(0xd, t[2]) ^ G(0x9, t[3]);
	    x[i+1] = G(0x9, t[0]) ^ G(0xe, t[1]) ^ G(0xb, t[2]) ^ G(0xd, t[3]);
	    x[i+2] = G(0xd, t[0]) ^ G(0x9, t[1]) ^ G(0xe, t[2]) ^ G(0xb, t[3]);
	    x[i+3] = G(0xb, t[0]) ^ G(0xd, t[1]) ^ G(0x9, t[2]) ^ G(0xe, t[3]);
	    i += 4;
	}
    }

    proc Cipher(in: @[4*Nb]_uint8, out: @[4*Nb]_uint8, w: @ExpandedKey)
    {   var round, Nr: _uint;
	var state: State;

	Nr = Nk + 6;    // number of rounds
	state = in@;
	AddRoundKey(state, w[0:Nb]);
	round = 1;
	while round < Nr do
	{
		SubBytes(state);
		ShiftRows(state);
		MixColumns(state);
		AddRoundKey(state, w[round*Nb:Nb]);
		round += 1;
	}
	SubBytes(state);
	ShiftRows(state);
	AddRoundKey(state, w[Nr*Nb:Nb]);
	out@ = state;
    }


    proc InvCipher(in: @[4*Nb]_uint8, out: @[4*Nb]_uint8, w: @ExpandedKey)
    {   var round, Nr: _uint;
	var state: State;

	Nr = Nk + 6;    // number of rounds
	state = in@;
	AddRoundKey(state, w[Nr*Nb:Nb]);
	round = Nr - 1;
	while round > 0 do
	{
	    InvShiftRows(state);
	    InvSubBytes(state);
	    AddRoundKey(state,  w[round*Nb:Nb]);
	    InvMixColumns(state);
		round -= 1;
	}
	InvShiftRows(state);
	InvSubBytes(state);
	AddRoundKey(state,  w[round*Nb:Nb]);
	out@ = state;
    }


    // Viewed as bytes
    // x[0] = x[1]; x[1] = x[2]; x[2] = x[3]; x[3] = x[0];
    proc RotWord(x: _uint32): _uint32: inline
    {
	return (x >> 8) | (x << 24);	// LE
    }

    proc SubWord(x: Word): Word
    {   var rv: Word;
	rv = sbox[_uint8(x)];
	rv = rv | (_uint32(sbox[_uint8(x>>8)]) << 8);
	rv = rv | (_uint32(sbox[_uint8(x>>16)]) << 16);
	rv = rv | (_uint32(sbox[_uint8(x>>24)]) << 24);
	return rv;
    }

    proc ExpandKey(keysz: KeySize, key: @[]_uint8, w: @ExpandedKey)
    {
	var temp: Word;
	var i, j, k, Nx: _uint;

	if keysz
	is KEY128 then Nk = 4;
	is KEY192 then Nk = 6;
	is KEY256 then Nk = 8;
	else
	{
	    // error "invalid keylength"
	}
	// Nr=Nk+6, the number of rounds    
	Nx = Nb*((Nk+6)+1);	// number of 32-bit words in key expansion
	i = 0;
	while i < Nk do
	{
    /*
	    // This just packs a big-endian 32-bit word
	    w[i] = (_uint32(key[4*i]) << 24) |
		   (_uint32(key[4*i+1]) << 16) |
		   (_uint32(key[4*i+2]) << 8) |
		   (_uint32(key[4*i+3]));
    */
	    // This just packs a little-endian 32-bit word
	    w[i] = (_uint32(key[4*i+3]) << 24) |
		   (_uint32(key[4*i+2]) << 16) |
		   (_uint32(key[4*i+1]) << 8) |
		   (_uint32(key[4*i]));
	    i += 1;
	}
	j = Nk; k = 0;
	while i < Nx do
	{   temp = w[i-1];
		if j == Nk then
		{   temp = SubWord(RotWord(temp)) ^ (_uint32(Rcon[k]));
		    j = 0;
		    k += 1;
		}
		else if Nk > 6 && i&3 == 0 then
		    temp = SubWord(temp);
		w[i] = w[i-Nk] ^ temp;
		i += 1;
		j += 1;
	}
    }   

    proc LoadKey(keysz: KeySize, key: @[]_uint8)
    {
	ExpandKey(keysz, key, KeyX);
    }

    proc Encrypt(in: @[4*Nb]_uint8, out: @[4*Nb]_uint8)
    {
	Cipher(in, out, KeyX);
    }

    proc Decrypt(in: @[4*Nb]_uint8, out: @[4*Nb]_uint8)
    {
	InvCipher(in, out, KeyX);
    }
}
// vim: ts=8 sw=4 noet nowrap

